from app.database.db import SessionLocal
from app.database.crud.detection import get_job_by_db_job_id
from app.internal import gitlab
from app.internal import model
from app.internal import report

async def start(
  db_job_id: int
):
  print("===> Beginning background tasks...")
  db_job, success, files = None, False, None
  try:
    db = SessionLocal()
    db_job = get_job_by_db_job_id(db=db, db_job_id=db_job_id) 
  finally:
    db.close()

  if db_job is None:
    print("===> Failed to retrieve job from database") # TODO: store status in database
    return
  
  success, files = await gitlab.get_related_files(
    gl_project_id=db_job.gl_project_id,
    gl_commit_sha=db_job.gl_commit_sha,
    diff=db_job.diff
  )
  if not success:
    print("===> Failed to retrieve relevant files from GitLab") # TODO: store status in database
    return

  success, start_time, end_time, scanner_metadata, analyzer_metadata, vulnerabilities = await model.run(files=files)
  if not success:
    print("===> Failed to run model") # TODO: store status in database, can save scanner and analyzer metadata as well
    return

  db_report = None
  try:
    db = SessionLocal()
    success, db_report = await report.create_and_save(
      db=db,
      success=success,
      start_time=start_time,
      end_time=end_time,
      analyzer_metadata=analyzer_metadata,
      scanner_metadata=scanner_metadata,
      vulnerabilities=vulnerabilities,
      remediations=[], # TODO: add remediation logic
      gl_job_id=db_job.id
    )
  finally:
    db.close()

  if not success:
    print("===> Failed to generate and save report") # TODO: store status in database
    return
  
  success = await gitlab.trigger_job(
    gl_project_id=db_job.gl_project_id,
    gl_pipeline_id=db_job.gl_pipeline_id,
    gl_job_id=db_job.gl_job_id
  )
  if not success:
    print("===> Failed to trigger manual job in GitLab") # TODO: store status in database
    return

  # TODO: store overall success status in database

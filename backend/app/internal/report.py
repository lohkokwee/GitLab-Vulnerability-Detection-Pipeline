from typing import Tuple, Optional
from sqlalchemy.orm import Session
from datetime import datetime
from uuid import UUID, uuid4

from app.database.schemas import report_base as base_schemas
from app.database.schemas import report_full as full_schemas
from app.database.crud import report as crud

async def create_and_save(
  db: Session,
  success: bool,
  start_time: datetime,
  end_time: datetime,
  analyzer_metadata: base_schemas.Analyzer,
  scanner_metadata: base_schemas.Scanner,
  vulnerabilities: list[base_schemas.Vulnerability],
  remediations: list[base_schemas.Remediation],
  gl_job_id: str
) -> Tuple[bool, Optional[full_schemas.SecurityReport]]:
  scan = base_schemas.Scan(
    analyzer=analyzer_metadata,
    start_time=start_time,
    end_time=end_time,
    scanner=scanner_metadata,
    status="success" if success else "failure",
    type="sast"
  )
  db_security_report = crud.create_security_report(
    db=db,
    scan=scan,
    vulnerabilities=vulnerabilities,
    remediations=remediations,
    gl_job_id=gl_job_id
  )
  return True, db_security_report

def create_vulnerability_schema(
  type: str,
  type_value: str,
  type_url: str,
  name: str,
  description: str,
  severity: str,
  location_file: str,
  location_start_line: int,
  location_end_line: int,
) -> base_schemas.Vulnerability:
  return base_schemas.Vulnerability(
    id=uuid4(),
    location=base_schemas.Location(
      file=location_file,
      start_line=location_start_line,
      end_line=location_end_line
    ),
    identifiers=[
      base_schemas.Identifier(
        type=type,
        name=f"{type.capitalize()}-{type_value}",
        value=type_value,
        url=type_url
      )
    ],
    name=name,
    description=description,
    severity=severity
  )

def create_scanner_schema(
  id: UUID,
  name: str,
  version: str,
  vendor_name: str,
) -> base_schemas.Scanner:
  return base_schemas.Scanner(
    id=id,
    name=name,
    version=version,
    vendor=base_schemas.Vendor(
      name=vendor_name
    )
  )

def create_analyzer_schema(
  id: UUID,
  name: str,
  version: str,
  vendor_name: str,
) -> base_schemas.Analyzer:
  return base_schemas.Analyzer(
    id=id,
    name=name,
    version=version,
    vendor=base_schemas.Vendor(
      name=vendor_name
    )
  )

# def mock() -> base_schemas.SecurityReport:
#   """Mocks a security report with details furnished from GitLab QA example (https://gitlab.com/gitlab-org/security-products/analyzers/semgrep/-/blob/main/qa/expect/js/jsx/gl-sast-schema.json).
#   """
#   vulnerability = base_schemas.Vulnerability(
#     id="d4bbd350-3b02-4915-8507-504186b3abc3",
#     location=base_schemas.Location(
#       file="/src/app/page.tsx",
#       start_line=2,
#       end_line=3,
#     ),
#     identifiers=[
#       base_schemas.Identifier(
#         type="cwe",
#         name="CWE-96",
#         value="96",
#         url="https://cwe.mitre.org/data/definitions/96.html"
#       )
#     ],
#     name="Improper neutralization of directives in dynamically evaluated code ('Eval Injection')",
#     description="The application was found calling the `eval` function OR Function()\n  constructor OR setTimeout() OR setInterval() methods. If the\n\n  variables or strings or functions passed to these methods contains user-supplied input, an adversary could attempt to execute arbitrary\n\n  JavaScript\n\n  code. This could lead to a full system compromise in Node applications or Cross-site Scripting\n\n  (XSS) in web applications.\n\n\n  To remediate this issue, remove all calls to above methods and consider alternative methods for\n\n  executing\n\n  the necessary business logic. There is almost no safe method of calling `eval` or other above stated sinks with\n\n  user-supplied input.\n\n  Instead, consider alternative methods such as using property accessors to dynamically access\n\n  values.\n\n\n  Example using property accessors to dynamically access an object's property:\n\n  ```\n\n  // Define an object\n\n  const obj = {key1: 'value1', key2: 'value2'};\n\n  // Get key dynamically from user input\n\n  const key = getUserInput();\n\n  // Check if the key exists in our object and return it, or a default empty string\n\n  const value = (obj.hasOwnProperty(key)) ? obj[key] : '';\n\n  // Work with the value\n\n  ```\n\n\n  For more information on why not to use `eval`, and alternatives see:\n\n  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!\n\n  Other References:\n\n  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function\n\n  - https://developer.mozilla.org/en-US/docs/Web/API/setTimeout\n\n  - https://developer.mozilla.org/en-US/docs/Web/API/setInterval\n",
#     severity="Medium",
#   )

#   scan = base_schemas.Scan(
#     analyzer=base_schemas.Analyzer(
#       id="NUS",
#       name="Security Vulnerability Detection LLM",
#       version=":SKIP:",
#       vendor=base_schemas.Vendor(name="NUS"),
#     ),
#     start_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
#     end_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
#     scanner=base_schemas.Scanner(
#       id="NUS",
#       name="Security Vulnerability Detection LLM",
#       version=":SKIP:",
#       vendor=base_schemas.Vendor(name="NUS"),
#     ),
#     status="success",
#     type="sast"
#   )

#   security_report = base_schemas.SecurityReport(
#     scan=scan,
#     vulnerabilities=[vulnerability]
#   )

#   return security_report

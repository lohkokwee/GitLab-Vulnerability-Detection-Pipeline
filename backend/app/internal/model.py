from typing import Tuple
import random
from datetime import datetime
from faker import Faker

from app.database.schemas.gitlab import FileContent
from app.database.schemas import report as schema
from app.internal.report import (
  create_schema_scanner, create_schema_analyzer, create_schema_vulnerability
)

async def run(files: list[FileContent]) -> Tuple[bool, str, str, schema.Scanner, schema.Analyzer, list[schema.Vulnerability]]:
  start_time = datetime.now()

  # TODO: metadata should change according to the models we use internally
  scanner_metadata = create_schema_scanner(
    id="SMU",
    name="Security Vulnerability Detection LLM",
    version=":SKIP:",
    vendor_name="SMU"
  )
  
  analyzer_metadata = create_schema_analyzer(
    id="SMU",
    name="SMU SCIS Vulnerability Analyzer",
    version=":SKIP:",
    vendor_name="SMU"
  )
  
  success, vulnerabilities = await mock_scan()
  end_time = datetime.now()
  return success, start_time, end_time, scanner_metadata, analyzer_metadata, vulnerabilities

async def mock_scan(files: list[FileContent]) -> Tuple[bool, list[schema.Vulnerability]]:
  fake = Faker()
  vulnerabilities: list[schema.Vulnerability] = []
  for f in files:
    vulnerabilities.append(
      create_schema_vulnerability(
        type="cwe",
        type_value="96",
        type_url="https://cwe.mitre.org/data/definitions/96.html",
        name=fake.sentence(),
        description=fake.sentence(),
        severity=random.choice(list(schema.SeverityLevels.__args__)),
        location_file=f.path,
        location_start_line=random.randint(1, 3),
        location_end_line=random.randint(4, 6)
      )
    )

  return True, vulnerabilities

async def scan(files: list[FileContent]) -> Tuple[bool, list[schema.Vulnerability]]:
  ... # TODO: insert actual model scanning logic
  return True
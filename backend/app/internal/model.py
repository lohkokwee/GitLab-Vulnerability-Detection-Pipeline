from typing import Tuple
import random
from datetime import datetime
from faker import Faker
from uuid import uuid4

from app.database.schemas.gitlab import FileContent
from app.database.schemas import report as schemas
from app.internal.report import (
  create_schema_scanner, create_schema_analyzer, create_schema_vulnerability
)

async def run(files: list[FileContent]) -> Tuple[bool, str, str, schemas.Scanner, schemas.Analyzer, list[schemas.Vulnerability]]:
  start_time = datetime.now()

  # TODO: metadata should change according to the models we use internally
  scanner_metadata = create_schema_scanner(
    id=uuid4(),
    name="Security Vulnerability Detection LLM",
    version=":SKIP:",
    vendor_name="SMU"
  )
  
  analyzer_metadata = create_schema_analyzer(
    id=uuid4(),
    name="SMU SCIS Vulnerability Analyzer",
    version=":SKIP:",
    vendor_name="SMU"
  )
  
  success, vulnerabilities = await mock_scan()
  end_time = datetime.now()
  return success, start_time, end_time, scanner_metadata, analyzer_metadata, vulnerabilities

async def mock_scan(files: list[FileContent]) -> Tuple[bool, list[schemas.Vulnerability]]:
  fake = Faker()
  vulnerabilities: list[schemas.Vulnerability] = []
  for f in files:
    vulnerabilities.append(
      create_schema_vulnerability(
        type="cwe",
        type_value="96",
        type_url="https://cwe.mitre.org/data/definitions/96.html",
        name=fake.sentence(nb_words=3),
        description=fake.sentence(nb_words=10),
        severity=random.choice(list(schemas.SeverityLevels.__args__)),
        location_file=f.path,
        location_start_line=random.randint(1, 3),
        location_end_line=random.randint(4, 6)
      )
    )

  return True, vulnerabilities

async def scan(files: list[FileContent]) -> Tuple[bool, list[schemas.Vulnerability]]:
  ... # TODO: insert actual model scanning logic
  return True